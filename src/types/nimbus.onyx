package nimbus

use core {
    stdio
}


/// The core `Nimbus` structure.
///
/// Contains all state of the current Nimbus server.
Nimbus :: struct {
    allocator: Allocator

    pre_pipes:  [..] Pipe
    post_pipes: [..] Pipe

    router: &Router
}


Nimbus.new :: (allocator := context.allocator) -> #Self {
    return .{
        allocator = allocator
        pre_pipes = make([..] Pipe, allocator)
        post_pipes = make([..] Pipe, allocator)
        router = new(router(), allocator)
    }
}

Nimbus.add :: (self: &#Self, method: HTTP_Method, path: str, handler: HTTP_Handler) {
    self.router->route(method, path, handler)
}

///
/// Searches in the specified package for procedures tagged with `route`
Nimbus.add_tagged_routes :: (self: &#Self, pack := builtin.any_package, group := "") {
    router_collect_routes(self.router, pack, group)
}


//
// Helper procedures to quickly add certain kinds of requests
//

Nimbus.get     :: (self: &#Self, path: str, handler: HTTP_Handler) { self->add(.GET, path, handler) }
Nimbus.post    :: (self: &#Self, path: str, handler: HTTP_Handler) { self->add(.POST, path, handler) }
Nimbus.put     :: (self: &#Self, path: str, handler: HTTP_Handler) { self->add(.PUT, path, handler) }
Nimbus.patch   :: (self: &#Self, path: str, handler: HTTP_Handler) { self->add(.PATCH, path, handler) }
Nimbus.delete  :: (self: &#Self, path: str, handler: HTTP_Handler) { self->add(.DELETE, path, handler) }
Nimbus.connect :: (self: &#Self, path: str, handler: HTTP_Handler) { self->add(.CONNECT, path, handler) }
Nimbus.options :: (self: &#Self, path: str, handler: HTTP_Handler) { self->add(.OPTIONS, path, handler) }
Nimbus.head    :: (self: &#Self, path: str, handler: HTTP_Handler) { self->add(.HEAD, path, handler) }



Nimbus.before :: #match #local {}

#overload
Nimbus.before :: (self: &Nimbus, x: HTTP_Handler) {
    pipe := Pipeable.as_pipe(x)
    self.pre_pipes->push(pipe)
}

#overload
Nimbus.before :: (self: &Nimbus, x: $T) where Pipeable(&T) {
    v := new(x, self.allocator)
    self.pre_pipes->push(Pipeable.as_pipe(v))
}

Nimbus.after :: #match #local {}

#overload
Nimbus.after :: (self: &Nimbus, x: HTTP_Handler) {
    pipe := Pipeable.as_pipe(x)
    pipe.after_commited = true

    self.post_pipes->push(pipe)
}

#overload
Nimbus.after :: (self: &Nimbus, x: $T) where Pipeable(&T) {
    v := new(x, self.allocator)

    pipe := Pipeable.as_pipe(v)
    pipe.after_commited = true

    self.post_pipes->push(pipe)
}


Nimbus.group :: (self: &Nimbus, prefix: str) -> &Nimbus {
    group := new(Nimbus.new(self.allocator))

    self.router->route(prefix, group.router)

    return group
}


//
// Request serving methods
//

Nimbus.serve :: (self: &#Self, port: u32, settings := TCP_Settings.{}) -> Serve_Status {
    pipeline := construct_pipeline(self)

    tcp_server := tcp_server_make(self.allocator, pipeline, settings)
    tcp_server.nimbus = self

    return tcp_server->serve(port)
}

Nimbus.cgi :: (self: &#Self, stream := &stdio.stream) {
    pipeline := construct_pipeline(self)

    cgi(self, pipeline, stream)
}


#local
construct_pipeline :: (self: &Nimbus) -> Pipeline {
    p := pipeline()

    for self.pre_pipes do p->pipe(it)

    p->pipe(self.router)

    for self.post_pipes do p->pipe(it)

    return p
}

