package nimbus

use core.encoding.json
use core.misc


Context :: #distinct &_context

#package
_context :: struct {
    nimbus: &Nimbus

    // The allocator for the current context
    allocator: Allocator

    req: &Request
    res: &Response

    // The stream to write the response to
    stream: &io.Stream

    variables: Map(str, any)
}

#package
make_context :: (
    nimbus: &Nimbus,
    req: &Request,
    res: &Response,
    stream: &io.Stream,
    allocator: Allocator
) -> _context {
    return .{
        nimbus,
        allocator,
        req,
        res,
        stream,
        make(Map(str, any), nimbus.allocator)
    }
}

#package
destroy_context :: (c: &_context) {
    Context.flush(~~ c)
    delete(&c.variables)
}


//
// Request methods
//

Context.request :: (self: Context) -> &Request {
    c := cast(&_context) self
    return c.req
}

Context.path :: (self: Context) -> str {
    c := cast(&_context) self
    return c.req.endpoint
}

Context.method :: (self: Context) -> HTTP_Method {
    c := cast(&_context) self
    return c.req.method
}

Context.header :: (self: Context, header: str) -> ? str {
    c := cast(&_context) self
    return c.req.headers[header]
}

Context.query :: #match #local {}

#overload
Context.query :: (self: Context, query: str) -> ? str {
    c := cast(&_context) self
    return c.req.query[query]
}

#overload
Context.query :: (self: Context, param: str, $Query_Type: type_expr) -> ? Query_Type {
    c := cast(&_context) self

    value := c.req.query[param]
    value->with([v] {
        return conv.parse_with_allocator(Query_Type, v, c.allocator)
    })
    return .None
}


Context.query_names :: (self: Context) -> [] str {
    c := cast(&_context) self
    return iter.as_iter(&c.req.params)
        |> iter.map(x => x.key)
        |> iter.collect(c.allocator)
}

Context.cookie :: (self: Context, cookie: str) -> ? str {
    c := cast(&_context) self
    return c.req.cookies[cookie]
}

Context.param :: #match #local {}

#overload
Context.param :: (self: Context, param: str, $Param_Type: type_expr) -> ? Param_Type {
    c := cast(&_context) self

    value := c.req.params[param]
    value->with([v] {
        return conv.parse_with_allocator(Param_Type, v, c.allocator)
    })
    return .None
}

#overload
Context.param :: (self: Context, param: str) -> ? str {
    c := cast(&_context) self
    return c.req.params[param]
}


Context.param_names :: (self: Context) -> [] str {
    c := cast(&_context) self
    return iter.as_iter(&c.req.params)
        |> iter.map(x => x.key)
        |> iter.collect(c.allocator)
}


Context.form_value :: #match #local {}

#overload
Context.form_value :: (self: Context, key: str, $Form_Type: type_expr) -> ? Form_Type {
    c := cast(&_context) self
    value := self->form_value(key)?
    return conv.parse_with_allocator(Form_Type, value, c.allocator)
}

#overload
Context.form_value :: (self: Context, key: str) -> ? str {
    c := cast(&_context) self
    body := request_get_body(c.req)

    form := body.Form?
    return form[key]?[0]
}


Context.json_raw :: (self: Context) -> ? json.Value {
    c := cast(&_context) self
    body := request_get_body(c.req)
    return body.Json?.root
}

Context.json_as :: (self: Context, $T: type_expr) -> ? T {
    val := self->json_raw()?
    return json.as_any(val, T)
}


//
// Response methods
//

/// Returns in the internal Response object of the Context.
/// You will likely never need to use this directly.
Context._response :: (self: Context) -> &Response {
    c := cast(&_context) self
    return c.res
}

Context.set_header :: (self: Context, header: str, value: str) {
    c := cast(&_context) self
    c.res.headers->put(header, value)
}

Context.set_cookie :: (self: Context, name: str, value: str) {
    c := cast(&_context) self
    c.res.cookies->put(name, value)
}

Context.write_headers :: (self: Context, code: u32) {
    c := cast(&_context) self
    c.res.status = code
    c.res.chunked = true
    response_write_headers(c.res, c.stream)
}

Context.no_content :: (self: Context, code: u32) {
    c := cast(&_context) self
    c.res.status = code
    response_write_headers(c.res, c.stream)
}

Context.redirect :: (self: Context, code: u32, uri: str) {
    c := cast(&_context) self

    if code < 300 || code > 308 {
        logf(.Warning, "Invalid HTTP status code for redirection ({}). Using 301 instead.", code)
        code = 301
    }

    c.res.status = code
    c.res.headers["Location"] = uri
    response_write_headers(c.res, c.stream)
    response_flush_body(c.res, c.stream)
}

Context.blob :: (self: Context, code: u32, mimetype: str, content: [] u8) {
    c := cast(&_context) self

    c.res.status = code
    c.res.headers["Content-Type"] = mimetype

    c.res.writer->write(content)

    response_write_headers(c.res, c.stream)
    response_flush_body(c.res, c.stream)
}

Context.json :: (self: Context, code: u32, data: any) {
    c := cast(&_context) self

    // Write the JSON to the response buffer
    json.encode(&c.res.writer, misc.any_dereference(data))

    c.res.status = code
    c.res.headers["Content-Type"] = "application/json"

    response_write_headers(c.res, c.stream)
    response_flush_body(c.res, c.stream)
}

Context.html :: (self: Context, code: u32, html: str) {
    self->blob(code, "text/html", html)
}

Context.file :: (self: Context, code: u32, mimetype: str, path: str) {
    push_context()

    c := cast(&_context) self
    context.allocator = c.allocator

    self->blob(code, mimetype, os.get_contents(path))
}

Context.writer :: (self: Context) -> &io.Writer {
    c := cast(&_context) self
    return &c.res.writer
}

Context.flush :: (self: Context) {
    c := cast(&_context) self
    response_flush_body(c.res, c.stream)
}




Context.get :: (self: Context, key: str, $T: type_expr) -> ? T {
    c := cast(&_context) self
    value := c.variables->get(key)?
    return misc.any_as(value, T) |> Optional.from_ptr()
}

Context.set :: (self: Context, key: str, v: any) {
    c := cast(&_context) self

    c.variables->put(
        str.copy(key, c.allocator)
        any_copy(v, c.allocator)
    )
}


Context.unwrap :: macro (self: Context, value: ? $T, status: u32) -> T {
    switch value {
        case .Some as v do return v
        case .None {
            self->blob(status, "text/plain", "Unwrapped empty Optional.")
            return #from_proc
        }
    }
}



#local
push_context :: macro () {
    c := context
    defer context = c
}

#local
any_copy :: (x: any, allocator: Allocator) -> any {
    use runtime.info
    use core.memory

    size := info.get_type_info(x.type).size
    new_data := allocator->alloc(size)
    memory.copy(new_data, x.data, size) 

    return .{ new_data, x.type }
}

