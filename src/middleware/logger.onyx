package nimbus

use core.encoding.json
use core {tprintf}

Logger :: struct {
    writer: io.Writer

    style := LoggerStyle.V1
}

LoggerStyle :: enum {
    V1
    V2
    JSON
}


logger :: (s: &io.Stream = &core.stdio.stream, style := LoggerStyle.V1) -> Logger {
    return .{
        io.writer_make(s),
        style
    }
}

#local
logger_log_request :: (l: &Logger, c: Context) {
    c->next()

    req := c->request()
    res := c->_response()

    switch l.style {
        case .V1 do 
            io.write_format(
                &l.writer,
                "[{}] {} {} {}{} - {}\n",
                context.thread_id,
                req.address.ip,
                req.method,
                req.headers["host"] ?? "", req.endpoint,
                res.status)

        case .V2 {
            status_color := "92"
            if res.status / 100 != 2 {
                status_color = "93"
            }
            if res.status >= 400 {
                status_color = "91"
            }

            io.write_format(
                &l.writer,
                "\e[37m[thread {}]\e[0m [\e[1;{}m{}\e[0m] \e[1;94m{} {}\e[0m  host: '{}' client: '{}'\n",
                context.thread_id,
                status_color,
                res.status,
                req.method,
                req.endpoint,
                req.headers["host"] ?? "",
                req.address.ip
            )
        }

        case .JSON {
            data := .{
                status = res.status
                method = tprintf("{}", req.method)
                endpoint = req.endpoint
                client = req.address.ip
            }

            json.encode(&l.writer, data)
            l.writer->write("\n")
        }
    }

    io.writer_flush(&l.writer)
    io.stream_flush(l.writer.stream)
}

#overload
ToMiddleware.convert :: macro (l: &Logger) => Middleware.{ logger_log_request, l }
