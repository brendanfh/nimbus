package nimbus

use runtime {info}
use core.os
use core { stdio }

#package
cgi :: (nimbus: &Nimbus, p: Pipeline, stream: &io.Stream) {
    req := make_request_from_env(stream)
    defer request_free(&req)

    res: Response
    response_init(&res)
    defer response_free(&res)

    c := make_context(nimbus, &req, &res, stream)

    pipe := p
    pipe->process(cast(Context) &c)
}

#package
make_request_from_env :: (stream: &io.Stream) -> Request {
    env := os.env_vars()

    req: Request

    req.method = info.enum_value(typeof req.method, env["REQUEST_METHOD"] ?? "")
    req.endpoint = env->get("PATH_TRANSLATED") ?? (env->get("PATH_INFO") ?? "")
    req._processed_endpoint = process_url_to_route_elems(req.endpoint)

    req.address.ip = env["REMOTE_ADDR"] ?? ""

    for iter.as_iter(env) {
        if str.starts_with(it.key, "HTTP_") {
            req.headers->put(str.advance(it.key, "HTTP_".count), it.value)
        }
    }

    req.headers["content-type"]   = env["HTTP_CONTENT_TYPE"] ?? ""
    req.headers["user-agent"]     = env["HTTP_USER_AGENT"] ?? ""
    req.headers["content-length"] = env["HTTP_CONTENT_LENGTH"] ?? ""

    query_string := env["QUERY_STRING"] ?? ""
    parse_url_encoded_key_value(&req.query, &query_string)
    
    parse_cookies(env["HTTP_COOKIE"] ?? "", &req.cookies)

    req.body_reader = new(io.reader_make(stream))

    return req
}

